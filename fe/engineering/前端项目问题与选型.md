# 前端项目问题与选型

## Monorepo

多个联系较为密切的项目需要同时进行维护的时候，更适合将所有项目放到同一个 Repo 中进行统一维护，使用 Lerna 和 yarn workspace 功能进行 Monorepo 的管理。一个典型的 Monorepo 项目目录如下：

```txt
- node_modules
- packages
  - package-a
    - node_modules
    package.json
  - package-b
    - node_modules
    package.json
  package.json
  lerna.json
```

项目统一放在`packages`文件夹中，每个项目有单独的配置。其中`lerna.json`是 Lerna 用来管理多个项目的配置文件，可以使用`lerna init`创建，其中`packages`字段指示了项目所在的目录。

```json
{
  "lerna": "2.0.0",
  "npmClient": "yarn",
  // 此参数表示lerna使用yarn workspace功能安装依赖
  "useWorkspaces": true,
  "packages": ["packages/*"]
}
```

使用`lerna bootstrap`启动项目时 Lerna 会调用`npm`或者`yarn`为每个项目分别安装依赖，并进行链接。在项目之前存在共同的依赖或者相互之间有依赖时，每个项目的`node_modules`文件夹会包含大量重复的包，使用`--hoist`选项可以将相同的依赖包提升安装到项目根目录的`node_modules`下被所有子项目共享，被依赖的子项目也会出现在`node_modules`中，使用软链接的方式指向子项目所在文件夹，这样互相依赖的子项目始终使用最新的代码而不必先发布被依赖的项目，然后才能使用新版本。最新的 yarn 内部直接实现了这个功能，所以直接使用 yarn 安装依赖包更方便。

```bash
# 等价于 lerna bootstrap --npm-client yarn --use-workspaces
yarn install
```

项目根目录下的`package.json`文件通常如下：

```json
{
  // 最底层项目设为私有，不允许发布
  "private": true,
  "name": "jest",
  "devDependencies": {
    "chalk": "^2.0.1"
  },
  // yarn使用此字段指定单个项目所在的文件夹，可以指定多个，当前不支持项目嵌套
  "workspaces": ["packages/*"]
}
```

[yarn workspace](https://yarnpkg.com/blog/2017/08/02/introducing-workspaces/)提供了和 lerna 一致的子项目管理功能，一个子项目在 yarn 中就是一个 workspace，使用 yarn workspace 命令可以对子项进行操作。

1. 复数命令为[所有子项目](https://yarnpkg.com/en/docs/cli/workspaces)添加、删除依赖
   ```bash
   yarn workspaces run add package-a
   yarn workspaces run remove package-a
   ```
1. 单数命令为[单个子项目](https://yarnpkg.com/en/docs/cli/workspace)添加、删除依赖（运行任何其他 yarn 命令）
   ```bash
   yarn workspace package-a add package-b
   yarn workspace package-a remove package-b
   ```
1. 在根目录项目运行命令，-W 是确认在根目录运行，不添加的话会提示报错。
   ```bash
   yarn add -W -D typescript
   yarn remove -W -D typescript
   ```

对于需要按照依赖关系以拓扑顺序为每个项目执行命令的情况，yarn 不提供支持，需要使用 lerna

```bash
lerna run --stream --sort build
```

## 打包工具对比（Webpack & Rollup）

### 编译模式配置

rollup 支持 typescript
配置 Rollup

```bash
npm install --save-dev rollup
npm install --save-dev rollup-plugin-typescript typescript tslib
npm install --save-dev rollup-plugin-sourcemaps
```

```json
  "scripts": {
      "build": "rollup -c"
  }
```

Rollup 编译配置放在 build 文件夹中 rollup.config.js/rollup.config.dev.js/rollup.config.prod.js

rollup 编译支持 ES6 即以上语法，使用插件 rollup-plugin-babel babel-core babel-preset-env babel-plugin-transform-object-rest-spread

```js
// ./`rollup.config.js`
import typescript from 'rollup-plugin-typescript'
import sourceMaps from 'rollup-plugin-sourcemaps'

export default {
  input: './src/main.ts',
  plugins: [
    typescript({
      exclude: 'node_modules/**',
      typescript: require('typescript'),
    }),
    sourceMaps(),
  ],
  output: [
    {
      format: 'cjs',
      file: 'lib/bundle.cjs.js',
      sourcemap: true,
    },
    {
      format: 'es',
      file: 'lib/bundle.esm.js',
      sourcemap: true,
    },
  ],
}
```

### 开发模式

插件 rollup-plugin-serve，使用 sourceMap

```js
const path = require('path')
const babel = require('rollup-plugin-babel')
const serve = require('rollup-plugin-serve')

const resolveFile = function (filePath) {
  return path.join(__dirname, '..', filePath)
}

module.exports = {
  input: resolveFile('src/index.js'),
  output: {
    file: resolveFile('dist/index.js'),
    format: 'umd',
  },
  plugins: [
    babel({
      presets: [
        [
          'env',
          {
            modules: false,
          },
        ],
      ],
      plugins: ['transform-object-rest-spread'],
    }),
  ],
}
```

开发模式配置

```js
const path = require('path');
const serve = require('rollup-plugin-serve');
const config = require('./rollup.config');

const resolveFile = function(filePath) {
  return path.join(__dirname, '..', **filePath**)
}
const PORT = 3001;

config.output.sourcemap = true;
config.plugins = [
  ...config.plugins,
  ...[
    serve({
      port: PORT,
      contentBase: [resolveFile('example'), resolveFile('dist')]
    })
  ]
]

module.exports = config;
```

### 生产配置

1. 代码混淆压缩 rollup-plugin-uglify（只支持 ES5)
1. 关闭 sourceMap

```js
const { uglify } = require('rollup-plugin-uglify')
const config = require('./rollup.config')

config.output.sourcemap = false
config.plugins = [...config.plugins, ...[uglify()]]

module.exports = config
```

### Linter

### EditorConfig

### Prettier

### VS Code Debugger

#### 调试 Jest 测试用例

### 测试

1. code coverage checking
1. code coverage checking

## Badges

https://shields.io/

#### 使用 Jest 测试 Typescript 项目

Jest 中支持 Typescript 有两种方式，使用[Babel](https://jestjs.io/docs/en/getting-started#using-typescript)来解析 Typescript 文件，转换为 Javascript 运行，但是 Babel 会去除 Typescript 的类型相关信息而不进行类型检查。更推荐使用[ts-jest](https://github.com/kulshekhar/ts-jest)。

1. 安装 jest 和 ts 依赖
   ```bash
   yarn add --dev jest typescript ts-jest @types/jest
   ```
1. 在配置文件`jest.config.js`中使用 ts-jest 配置
   ```js
   module.exports = {
     preset: 'ts-jest',
     testEnvironment: 'node',
   }
   ```
1. 在`package.json`中添加`test`命令。
   ```json
     "scripts": {
       "test": "jest --no-cache"
     }
   ```
1. 测试覆盖率 coverage

## CI & CD

## 提交配置

使用[Conventional Commit](https://www.conventionalcommits.org/en/v1.0.0/)规范定义的提交规范，格式如下。

```txt
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

命令行工具[commitlint](https://www.google.com/search?q=commitlint&oq=commitlint&aqs=chrome..69i57j69i59j69i60l2.3343j0j4&sourceid=chrome&ie=UTF-8)用来对提交信息的格式进行检查，使用库 husky 来注册`commit-msg`钩子，在提交时自动进行信息格式检查。

```bash
yarn add -W -D @commitlint/cli @commitlint/conventional-commit @commitlint/config-lerna-scopes lint-staged husky
yarn add -W -D commitizen cz-conventional-changelog
```

```js
// commmitlint.config.js
module.exports = {
  extends: [
    "@commitlint/config-conventional"
    // lerna monorepo增加每个包名作为合法的scope
    "@commitlint/config-lerna-scopes"
  ]
};
```

```package.json
"scripts": {
   commit: "git-cz"
 },
 "config": {
    "commitizen": {
      "path": "cz-conventional-changelog"
    }
  },
  "husky": {
    "hooks": {
      "prepare-commit-msg": "exec < /dev/tty && git cz --hook || true",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS",
      "pre-commit": "yarn run test:changed"
    }
  },
```

正常使用`git commit`提交触发钩子`prepare-commit-msg`从而使用`git cz`交互式进行提交。

## 发布配置

1. version bump
   根据 conventional commit 信息自动发布，

```bash
lerna version --conventional-commits
```

或者手动指定版本发布

```bash
lerna version
```

```json
// lerna.json
{
  "packages": ["packages/*"],
  "version": "independent",
  "npmClient": "yarn",
  "command": {
    "publish": {
      "ignoreChanges": ["*.md"],
      "verifyAccess": false,
      "verifyRegistry": false,
      "message": "chore: publish" // 自定义version生成的message记录
    }
  }
}
```

发布时有两种模式

1. fixed/locked - 所有子项目版本保持一致
2. independent - 子项目版本独立，可以单独升级

## 文档配置

## 发布

1. https://github.com/lerna/lerna
1. https://zhuanlan.zhihu.com/p/71385053

1. https://egghead.io/lessons/javascript-introduction-to-how-to-write-an-open-source-javascript-library
