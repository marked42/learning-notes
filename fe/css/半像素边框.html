<!DOCTYPE html>

<html>
  <style>
    .container {
      width: 200px;
      height: 100px;
      display: flex;
      align-items: center;
      margin: auto;
      justify-content: space-around;
      background: lightgray;
    }
    .block {
      color: #FF2442;
      height: 16px;
      font-family: PingFang SC;
      font-style: normal;
      font-weight: normal;
      font-size: 11px;
      line-height: 12px;
      padding: 2px;
      position: relative;
      box-sizing: border-box;
      overflow: hidden;
    }
    .block:after {
      position: absolute;
      top: 0;
      left: 0;
      content: '';
      box-sizing: border-box;
      width: 200%;
      height: 200%;
      border-radius: 8px;
      border: 1px solid #ff2442;
      transform: scale(.5);
      transform-origin: top left;
      pointer-events: none;
    }
    .block.block2 {
      overflow: visible;
    }
  </style>
  <body>
    <div class="container">
      <div class="block">1元直播券</div>
      <div class="block block2">1元直播券</div>
    </div>
    <p>
      将伪元素使用transform两倍放大，设置1px边框然后缩小0.5到原来的尺寸大小，以像素为单位的元素尺寸计算可以是小数，但是渲染时最终会取整到整数值，
      所以可能出现元素尺寸x的取整和伪元素取整数值最终不一致的情况，相差1px。伪元素使用的是左上角对齐父元素的绝对定位，所以右边界1px的像素会超出父元素的边界，
      如果父元素设置了overflow: hidden那么这个伪元素的有边框就不会显示出来，造成左边这种情况。
    </p>
  </body>
</html>
