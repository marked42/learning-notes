# 作用域闭包与函数

## TOC

调用的四种方法

1. function `this`绑定到global，`undefined`严格模式
1. method
2. constructor
3. call/apply

函数调用表达式的详细解析过程：

1. 参数确定过程
2. `this`绑定过程
3. 返回值确定过程

构造函数调用`new Fun()`，如果函数有`return`语句，返回基本类型的话，构造函数调用的值等于`this`默认绑定到的新建对象；如果函数`return`语句返回对象类型的话，构造函数表达式的值为这个对象。

1. 箭头函数的this绑定到箭头函数创建时的context上，全局window对象或者Function Execution Context的scope对象。箭头函数的this绑定不能修改，
1. bind函数，返回一个绑定了context的新函数，新函数的context不能再修改
2. 箭头函数可以调用bind，但是不能重新绑定this，bind也可以重复调用但是只有第一次生效。
1. 一个绑定了this之后就不能改变了？

1. lexical scopes/environment 包含哪些数据，identifiers ?
1. lexical environment 和 execution context区别？
1. identifier 注册的过程？注册和执行两个阶段？
2. global
3. function
4. block with let/const
建立嵌套的environment的过程，识别所有的identifier即其值

1. 左值（lefthand-side）引用找不到的情况下：
  1. 非严格模式，自动在全局环境（Global Scope）中声明该变量
  1. 严格模式，禁止自动创建变量而是抛出错误`ReferenceError`
1. 右值（righthand-side）引用在整个嵌套环境（Scope）中找不到的情况下，抛出错误`ReferenceError`

赋值语句的处理分为两步`var a = 2`

1. 编译阶段，从当前环境中开始寻找标识符`a`是否已经声明，并在非严格模式下自动声明。
1. 运行阶段，`a = 2`执行赋值操作
1. hoisting 变量提升限定各自的作用域内 函数声明(Function Declaration)/变量声明 可以提升，函数表达式不会提升
```js
foo() // TypeError, not ReferenceError
bar() // ReferenceError 函数表达式的名称不会注册在所在作用域上

var foo = function bar() {
// ...
};
```

```js
foo(); // 1
var foo;

// 同时有同名的函数声明和变量声明时，函数声明优先，因为函数声明在编译阶段就确定在Scope对象上了，变量声明分成两步处理，编译时只是在Scope上添加了变量，值是undefined，赋值发生在运行时
function foo() {
  console.log( 1 );
}

foo = function() {
  console.log( 2 );
};

// 重复的函数声明，后面覆盖前面
function foo() {
  console.log( 2 );
}
```

三种形式对于Scope的影响
```js
var a;

var a = 1;

a = 1;
```

[[Environment]]
作用域（Scope）有两种实现方式
变量（Variable）
标识符（Identifier）
1. 语法作用域（Lexical Scope）机制，在代码编译的语法解析阶段确定，由标识符在源码中的位置决定。
    1. 全局作用域（Global Scope）,函数作用域和块作用域
    1. 嵌套机制
    1. `var a`在所在的最近一层函数作用域或者全局作用域声明变量`a`，块级作用域被忽略
    1. `let/const`尊重块级作用域
    1. 全局对象的属性`window.innerHeight`可以在全局作用域中直接使用`innerHeight`访问，忽略`window`，但是可以在全局作用域中声明同名变量`innerHeight`从而使全局对象的属性`window.innerHeight`只能通过全称来访问。
    1. `eval(source_code_string)`可以动态的改变所在作用域的变量，效果等同于`source_code_string`是源码的一部分而执行，严格模式下`eval()`有自己独立的作用域，代码在该作用域运行而不影响外部作用域。
        1. `var timeoutID = scope.setTimeout(code[, delay]);`
        1. `var timeoutID = scope.setInterval(code[, delay]);`
    1. 在运行时临时创建一个新的作用域，
    ```js
    // with将左值引用a变成了对于obj的属性'a'的引用，如果obj上没有属性'a'会造成对于a的查找泄露到外层全局作用域，可能隐式地创建变量`a`
    function foo(obj) {
      with (obj) {
        a = 2;
      }
    }
    ```
    1. `eval`/`with`的优点和缺点都在于可以在运行时影响语法环境，优点在于灵活，缺点在于编译器无法在编译期对于变量作用域进行静态分析，从而提高代码性能。
    1. `new Function('a', 'b', 'return a + b')`不会创建自己的语法环境而是在全局环境执行，因此`a`/`b`引用的是全局作用域变量。
    1. `try/catch`
    ```js
    try {
      undefined(); // illegal operation to force an exception!
    }
    // linter对于重复名称err会报错，但是这是合法的,
    // err是block scoped
    catch (err) {
      console.log( err ); // works!
    }

    try {}
    // linter对于重复名称err会报错，但是这是合法的
    // err是block scoped
    catch (err) {
      console.log( err ); // works!
    }

    console.log( err ); // ReferenceError: `err` not found
    ```
  1. let loops

1. 动态作用域（Dynamic Scope）机制


## for循环的作用域

```javascript
for (let i = 0; i < 10; i++) {
  console.log(i);
}
```

等价与以下形式

```js
{
  let j; // 在所有循环共享
  for (j = 0; j < 10; j++) {
    let i = j; // 每次循环定义一个新的块级作用域与局部变量
    console.log(i);
  }
}
```

## 闭包例题

```javascript
// timeline: 0s --> 1s --> 2s --> 3s --> 4s --> 5s
// output:          5      5      5      5
for (var i = 1; i < 5; i++) {
    setTimeout(function timer() {
        console.log(i)
    }, i * 1000)
}
```

每隔1s输出一个5，总共4个，因为`for`循环同步执行完成后外层`i = 5`，然后4个`timer`函数使用的是同一个`i`，依次异步执行输出。

想要每个`timer`函数输出的结果不一样，就要使用闭包为每个`timer`函数提供不同的值，使用IIFE函数作用域的方式。

```js
// timeline: 0s --> 1s --> 2s --> 3s --> 4s --> 5s
// output:          1      2      3      4
// each loop creates a closure of j inside an IIFE
for (var i = 1; i < 5; i++) {
    (function() {
        // 变量j定义在内层函数作用域中
        var j = i
        setTimeout(function timer() {
            console.log(j)
        }, i * 1000)
    })()
}
```

更简洁的方式是使用函数参数

```js
// timeline: 0s --> 1s --> 2s --> 3s --> 4s --> 5s
// output:          1      2      3      4
for (var i = 1; i < 5; i++) {
    (function(j) {
        setTimeout(function timer() {
            console.log(j)
        }, i * 1000)
    })(i)
}
```

更简洁的方式是利用`setTimeout`函数本身来提供函数作用域，多余的参数会被传给`timer`函数。

```js
// timeline: 0s --> 1s --> 2s --> 3s --> 4s --> 5s
// output:          1      2      3      4
for (var i = 1; i < 5; i++) {
    setTimeout(function timer(i) {
        console.log(i)
    }, i * 1000, i)
}
```

利用ES6的特性，`let`变量具有块级作用域，`for`循环的每一次都创建一个新的块作用域，其中的`j`值不同。

```js
// timeline: 0s --> 1s --> 2s --> 3s --> 4s --> 5s
// output:          1      2      3      4
// let/const creates a block scope closure on each iteration
for (var i = 1; i < 5; i++) {
    let j = i
    setTimeout(function timer() {
        console.log(j)
    }, i * 1000)
}
```

更简洁的方式是直接声明`let i`

```js
// timeline: 0s --> 1s --> 2s --> 3s --> 4s --> 5s
// output:          1      2      3      4
// let/const creates a block scope closure on each iteration
for (let i = 1; i < 5; i++) {
    setTimeout(function timer() {
        console.log(i)
    }, i * 1000)
}
```

## `this`

函数调用时生成新的函数执行环境，添加到函数执行栈顶部，函数执行环境记录了函数执行的相关信息。

`this`关键字代表的值在函数执行时确定，有一下几种情况。

#### 构造函数调用

正常的函数使用`return obj`显式返回对象`obj`或者隐式返回`undefined`。构造函数调用`new Fun()`首先创建一个新的空对象，然后将`this`绑定到该对象，并在构造完成后返回该对象。

#### 显式绑定

使用函数`Function.prototype.call(context, arg1, arg2, ...)`和`Function.prototype.apply(this, args)`将`this`显式绑定到`context`参数代表的对象上。
`null`, `undefined`传参给`call`, `apply`, `bind`被忽略，默认绑定规则生效.

函数`Function.prototype.bind(context)`返回一个新函数，这个函数等同于原来的函数，区别在于新函数的`this`固定的绑定到`context`参数上，再次调用`bind/call/apply`都无法重新绑定`this`。

ES5环境下对于`bind`函数的模拟实现。

```javascript
if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError(
        "Function.prototype.bind - what is trying to be bound is not callable"
      );
    }

    var aArgs = Array.prototype.slice.call(arguments, 1)
    var fToBind = this
    var fNOP = function() {}
    var fBound = function() {
        return fToBind.apply(
          this instanceof fNOP ? this : oThis,
          aArgs.concat(Array.prototype.slice.call(arguments))
        )
      }

    // maintain prototype chain
    if (this.prototype) {
      // Function.prototype doesn't have a prototype property
      fNOP.prototype = this.prototype;
    }
    fBound.prototype = new fNOP();

    return fBound;
  };
}
```

有几个点需要注意：

1. `Function.prototype.bind`返回函数`fBound`，`this`绑定到`oThis`上。
1. `bind(this, arg1, arg2, ...)`函数的其他参数也强制绑定作为新函数调用时开头的参数，所以需要拼接参数。
1. 新函数作为构造函数调用时应该尊重构造函数的语义，构造函数的`this`绑定到一个空对象。为了区分构造函数调用和普通函数调用，在`bind`内部声明了一个函数，并将其插入到原型链中。
因为`fNOP`是函数内部声明，所以此函数之外不可能引用得到。这样`this istanceof fNOP`为真时表明新函数作为构造函数被调用，否则将`this`绑定到`oThis`指定的对象。

![Prototype Chain of Bind Function](function_bind.png)

#### 隐式绑定

```javascript
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo
};

obj.foo(); // 2
```

函数`obj.foo()`作为对象方法被调用时`this`隐式绑定到调用对象本身.

#### 默认绑定

```javascript
function foo() {
  console.log(this.a);
}
var a = 2; // a is window.a in browser environment
foo(); // 2
```

普通模式下`this`默认绑定到全局对象`window`上，严格模式下报错。

```javascript
if (!Function.prototype.softBind) {
    Function.prototype.softBind = function(obj) {
        var fn = this;
        // capture any curried parameters
        var curried = [].slice.call( arguments, 1 );
        var bound = function() {
        return fn.apply(
            (!this || this === (window || global)) ?
            obj : this
            curried.concat.apply( curried, arguments )
            );
        };
        bound.prototype = Object.create( fn.prototype );
        return bound;
    };
}
```

`softBind`检查`this`是`null`/`undefined`/`window`的话将`this`绑定到`obj`

Another tricky example.

```js
function one () {
  // 1. this bind to window, set window.name to 1
  this.name = 1;

  return function two () {
    // 2. set to window.name to 2
    name = 2;

    return function three() {
      var name = 3;
      // 3. this bind to window, window.name is now 2
      console.log(this.name);
    }
  }
}
one()()()  // => 2;
```

#### 箭头函数

箭头函数的`this`在运行时箭头函数所在的语法作用域（全局作用域全局对象`window`或者函数作用域的`this`）的`this`，绑定之后不能再改变。箭头函数不能使用`new`关键字作为构造函数调用，否则抛出错误`TypeError 'x' is not a constructor`。

```javascript
const globalScope = () => {
  console.log("this bound to global: ", this);
};

function foo() {
  return a => {
    // `this` here is lexically inherited from `foo()`
    console.log(this.a);
  };
}

var obj1 = { a: 1 };
var obj2 = { a: 2 };
var boundToObj1 = foo.call(obj1);
boundToObj1(); // 1
boundToObj1.call(obj2); // 1

var boundToObj2 = foo.call(obj2);
boundToObj2(); // 2
boundToObj2.call(obj1); // 2

boundToObj1 !== boundToObj2;
```
