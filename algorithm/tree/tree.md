# 树

## 2-3 树

2-3 树中包含两种节点：2 结点和普通二叉树的节点一样，节点中包含一个值且有两个子节点（包含空节点）；3 节点中包含两个节点值且有三个子节点。2-3 树通过 3 节点能够容纳多一个节点的性质保持树的平衡。

![2-3 Tree](./2-3-tree.png)

### 插入操作

向 2-3 树中插入一个节点首先根据要插入的键值进行查找，如果树中存在相同的键直接更新即可；如果不存在需要在最终查找到的叶节点下新增子节点。新增子节点可以分为几种情况。

#### 根节点为空

插入新节点是根节点

#### 向 2 节点插入新节点

2 节点变为 3 节点

![2-3-tree-insert-into-2-node](./2-3-tree-insert-into-2-node.png)

#### 向 3 节点插入新节点

3 节点插入新节点变为临时的 4 节点，然后需要将 4 节点向上分解以消除 4 节点。如果 3 节点的父节点是 2 节点，那么分解 4 节点后父节点变为 3 节点。

![2-3-tree-insert-into-3-node](./2-3-tree-insert-into-3-node.png)

如果 3 节点的父节点是 3 节点，那么 4 节点分解后父节点变为新的 4 节点，需要继续向上分解直到父节点是 2 节点或者是根节点。4 节点是根节点的情况下，4 节点分解后其中间成为新的根节点，且 2-3 树高度加 1。

![2-3-tree-insert-into-3-node](./2-3-tree-split-4-node.png)

## 红黑树

### [左倾红黑树（**L**eft **L**earning **R**ed **B**ack **T**ree)](https://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf)

2-3 树中的 3 结点和临时的 4 结点内部结点之间的**连接**定义为红色，其余连接定义为黑色。这样定义下每一个 2-3 树都可以有对应红黑树（连接带有颜色的二叉树）表示。

1. 黑色连接等同于 2-3 树中的节点间的连接
1. 红色连接相当于于 2-3 树中 3 结点和临时的 4 结点的内部连接
1. 红色连接相连的节点相当于 2-3 树中的 3 节点和临时 4 节点
1. 2-3 树中树的平衡相当于红黑树中黑色连接的平衡，红色连接等同于 2-3 树节点内部连接不增加其高度

一个 2-3 树的对应红黑树不是惟一的。

![Left Leaning Red Black Tree](./left-leaning-red-black-tree.jpeg)

为了简化可能的情况，只使用红色左连接而禁止使用红色右连接，这样的红黑树就叫左倾红黑树。2-3 树和左倾红黑树是**一一对应**的。左倾红黑树是黑连接平衡的，即从根节点到任意叶节点经过的黑色连接个数是相同的。左倾红黑树必须满足以下几条性质：

1. 红黑树的根节点总是黑色的 - 对应 2-3 树中根节点是 2 节点和根节点是 3 节点其中较大的节点。
2. 空的子节点也当成黑色处理 - 平衡 2-3 树中最底层叶节点的子节点是空节点
3. 不允许出现红色右连接 - 左倾红黑树的要求
4. 不允许出现出现两条连续的红色左连接 -对应 2-3 树中临时 4 节点，在插入删除节点操作完成时被消除

在左倾红黑树进行插入和删除节点的过程中如果保持以上的性质，就相当于等价表示的 2-3 的树在插入删除节点过程中保持平衡。红黑树中除了插入和删除节点之外的查询操作和普通的二叉树完全一样，不需要做任何修改，这也是红黑树相比于 2-3 树简单的地方。

二叉树中一个结点向下可以有两个连接，但是向上只有一个连接到其父结点，因此可以将每条连接的是红连接还是黑连接的信息保存在连接子结点当中。结点中保存一个布尔值，`true`表示这个结点是红结点，到其父结点的连接是红连接，反之是黑结点。

#### 左旋和右旋

2-3 树中三节点可以用红色左连接或者红色右连接的红黑树表示，左旋和右旋操作将两种形式互相转换。以左旋操作为例，子树根节点`F`到右子节点`Q`的红色右连接被转换成了根节点`Q`到左子节点`F`的红色连接。左旋和右旋操作是局部变换，只需要修改涉及到的两个节点即可，在常数时间内完成。

![LLRB Rotate Left & Right](./llrb-rotate-lef-right.png)

需要注意的是左右旋操作改变了子树的根节点，因此使用时应该对代表根节点的变量进行更新。

```java
Node h = rotateLeft(h);
```

#### 颜色转换（消除临时 4 节点）

2-3 树中分解临时 4 节点的操作等价于左倾红黑树中对一个左右都是红连接的节点变成黑色（4 节点分解），并将节点本身的颜色变成红色（节点上浮）。

![LLRB Flip Colors](./llrb-flip-color.png)

#### 插入结点操作

红黑树插入节点操作对应于 2-3 树，新插入的节点与父节点之间是红色连接，相当于 2-3 树中 2 节点/3 节点增加一个节点变成 3 节点/4 节点。旋转与变色操作相当于 2-3 树中将 4 节点进行向上分解。向 3 节点插入新节点时才会形成 4 节点，需要向上分解处理，新节点可能插入在 3 节点的左中右三个位置。

![Rotate then Flip color](./rotate-then-flip-color.png)

对应上图中三种情况

1. 新节点插入中间 - 将红色右连接左旋
1. 新节点插入左侧 - 出现连续两条红色左连接，将根节点上方左连接右旋
1. 新节点插入右侧 - 如果左右连接都是红色，进行变色操作将红色连接向上传递。

这样在左倾红黑树插入节点的过程中就可以始终保持其性质从而使其保持接近平衡。递归实现的代码如下：

```java
public class RedBlackBST<Key extends Comparable<Key>, Value> {
    private Node root;

    public void put(Key key, Value val) {
        root = put(root, key, val);
        // 维持根节点是黑色
        root.color = BLACK;
    }

    private Node put(Node h, Key key, Value val)
    {
        if (h == null)
           return new Node(key, val, 1, RED);

        int cmp = key.compareTo(h.key);
        if      (cmp < 0) h.left  = put(h.left,  key, val);
        else if (cmp > 0) h.right = put(h.right, key, val);
        else h.val = val;

        if (isRed(h.right) && !isRed(h.left))    h = rotateLeft(h);
        if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h);
        if (isRed(h.left) && isRed(h.right))     flipColors(h);

        h.N = size(h.left) + size(h.right) + 1;
        return h;
    }
```

注意递归实现中变色操作放在最后，这样在当前节点递归结束后其对应子树中不存在对应 4 节点的连续红色连接。如果节点向上传递了红色连接，该红色连接与更上层红色连接形成的连续连接被上层节点的函数消除。根节点的向上传递红色连接会将树高增加 1，此处需要手动将根节点重新恢复成黑色。

#### 删除节点操作

#### 自顶向下的 2-3-4 树插入操作（Top Down)

#### 红黑树的性质

1. 红黑树的操作在线性对数级别。一棵大小为$N$的红黑树高度不会超过$2\log N$。比普通二叉树平均路径长度少 40%.
1. 有$N$个内部节点红黑树中，根节点到任意节点的平均路径长度是约为$\log N$

### 标准红黑树

算法导论中介绍了不限制红色链接倾斜方向的标准红黑树，并将树中的节点分为内部节点（internal node）和外部节点（external node）两种。

1. 内部节点 - 存储一个具体键值的节点，包括`color`、`key`、`left`、`right`、`parent`等属性。
1. 外部结点 - 外部节点是为了分析方便，保证每个内部节点都有子节点。可以用空指针`NIL`或者哨兵（sentinel）节点实现，算法导论中为节省空间使用一个哨兵`T.nil`元素作为所有内部节点的子节点。

红黑树来源于平衡 B 树，用节点带有红黑颜色的平衡二叉搜索树来代表等价的 B 树，并实现保持平衡 B 树的相应插入删除节点操作，所以我们从可以从 B 树的角度来理解这些性质。

标准红黑树等价于 2-3-4 树，2-3-4 树中包含三种节点。

1. 2 节点（2-node）- 有一个键`key`和两个子节点`left`、`right`，其中`left < key < right`。
2. 3 节点（3-node）- 有两个键和三个子节点，键值和节点满足大小顺序。
3. 4 节点（4-node）- 有三个键和四个子节点，键值和节点满足大小顺序。

如下图椭圆形代表 3 节点内部包含两个节点`a`、`b`，黑色小方块代表外部节点，节点间加粗的线代表红色连接，节点的圈加粗的代表红色节点。

![Red Black Tree 3-node](./rb-tree-3-node.png)

两个二叉树节点连接在一起表示一个 3 节点，使用红色连接还是红色节点是对这一表示的不同说法。红色连接的方式更加直观，红色链接是 2-3-4 树中的节点的内部连接，黑色连接是节点的外部连接。红色节点表示的话，有个叫做提升（lifting）节点的操作，就是将红色节点提升到与黑色父节点一样的高度，也表示两个二叉树节点合在一起对应一个三节点。标准红黑树中不限制红色节点是左倾（红色节点是左子节点）还是右倾（红色节点是右子节点），所以有两种表达方式。

4 节点使用红色或黑色的二叉树节点表示如下：

![Red Black Tree 4-node](./rb-tree-4-node.jpeg)

不考虑左右倾有 5 种表示形式，但是其中前 4 种树的高度是 2，第五种对称形式一个黑色父节点两个红色子节点树高度是 1。表示 4 节点时只使用第 5 种形式二叉树的高度会更低，其余 4 种形式在插入操作中作为中间状态可能出现。

平衡 2-3-4 树的等价红黑树必须满足以下五条性质。

| 编号 | 性质                                                                           | 说明                                                                                                                                                                                              |
| ---- | ------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | 每个节点是红色或是黑色                                                         | 删除节点过程中单个节点可能临时代表双黑或者黑红                                                                                                                                                    |
| 2    | 根节点是黑色的                                                                 | 对应 2 节点 3 节点的根必定时黑色的，对应 4 节点的根节点颜色是黑是红并不影响树的平衡和拓扑结构，统一规定为黑色是为了与 2 节点 3 节点的表示一致，这意味着需要的时候将根节点从红色改为黑色是允许的。 |
| 3    | 叶节点（NIL）是黑色的                                                          | 叶节点是外部节点，不与其父节点合并表示 3 节点 4 节点，所以规定为黑色的。                                                                                                                          |
| 4    | 如果一个节点是红色的，则它的两个子节点都是黑色的                               | 禁止了 4 节点对应的高度为 2 的表示形式。                                                                                                                                                          |
| 5    | 对于每个节点，从该节点到其所有后代节点的简单路径上，均包含相同数目的黑色节点。 | 平衡的 2-3-4 树中从根节点到任意叶节点高度路径长度相同，路径上包含的黑色节点个数相同。                                                                                                             |

红黑树从根节点到外部节点的所有路径中最短的路径是只有黑色节点的路径，最长的路径是黑色节点红色节点交替出现的路径，因为不允许连续的红色节点。最长路径长度不超过最短路径长度的 2 倍，因此是近似于平衡的，这种近似平衡对应的就是 2-3-4 树的平衡性质。

从某个节点出发（不含该节点）到达一个外部节点的任意一条简单路径上黑色节点个数称为该节点的黑高（black-height）。红黑树的黑高为其根节点的黑高。

一个内部有 n 个节点的红黑树高度最多是$2\log (n+1)$。首先证明黑高为$bh$树中至少包含$2^{bh} - 1$个节点（不包含任何红色节点的情况，是一个只有黑色节点的高度为$bh$的完全平衡二叉树）。$n \ge 2^{bh} - 1 \rightarrow 2\log (n+1) \ge bh$。

#### 旋转操作

标准红黑树中的旋转操作和左倾红黑树中一样，不同的是算法导论中描述的旋转的操作不涉及节点颜色，插入删除操作中对节点的颜色变换另外进行设置。另外要考虑到旋转操作涉及根节点时，要对代表二叉树根节点的变量`T.root`进行正确更新。

注意旋转操作为了位置二叉树节点键值大小顺序的要求在变换左倾右倾方向的同时会交换父子节点的键值。

![Red Black Tree Rotation](./rb-tree-rotation.png)
![Red Black Tree Rotation](./rb-tree-rotate-left.png)

保持平衡的旋转操作应该造成两个节点的颜色互换，也可以考虑将这一变化包含到旋转操作中简化某些情况下手动对节点变色的操作。

#### 插入操作

算法导论中描述的插入操作使用了循环的方式实现，在普通二叉树的插入操作上进行 RB-INSERT-FIXUP 操作修复红黑树性质。

插入节点操作的实现思路是将插入的键值`key`与根节点进行比较，小的话继续在左子树重复此步骤，大的话继续在右子树重复此步骤，记录当前节点知道要出入的位置为空（等于哨兵元素）即找到了目标插入位置。同时注意处理树为空的情况。

![RB Insert](./rb-insert.png)

插入的节点默认为红色节点，因为对于一个当前黑平衡的红黑树插入黑色节点是无法保持树的黑平衡的，而插入红色节点不影响红黑树的黑平衡性质（性质 5），只可能破坏性质 1（空树插入一个节点）或者性质 4（在红色节点下插入新的红色节点）。

对于性质 4 的破坏称之为**双红缺陷**，对应有两种情况。

向 4 节点中插入 - 对应 2-3-4 树中的上溢（overflow）情况，即向一个 4 节点中插入新节点会出现 2-3-4 树中允许存在的 5 节点，修复的方法是将 4 节点拆分上浮。在红黑树中是将 4 节点两个红色子节点变为黑色，根节点变为红色，将红色节点上浮进行下一轮循环（同样可以像左倾红黑树中用递归实现）。

向 3 节点中插入 - 修复的方法相当于将标准红黑树中不允许的 4 节点 4 种表示形式转换为形式 5（高度为 1 的对称表示形式）。修复的方法和左倾红黑树中类似，都是将**之字形(zig zag)**的情况转换为**一条直线**的情况再转换为对称表示的情况。需要注意的是和左倾红黑树中不同，标准红黑树中允许存在 4 节点（即 4 节点的形式 5）。

![RB Insert 3-node](./rb-tree-insertion-3-node.png)

实现中注意区分左倾右倾两种对称的情况，循环结束的情况是父节点不是红色节点，即不再出现连续红色节点，性质 4 被修复。最后循环结束时红色节点可能被上浮到了父节点，因此将父节点颜色重新修改为黑色，修复性质 2。

![RB Insert Fixup](./rb-insert-fixup.png)

#### 持久化数据结构（persistent data structure）

注意红黑树的插入操作修复过程只需要常数时间的旋转操作（改变二叉树拓扑结构）和最多$O(\log n)$的变色操作（只改变节点数据不改变二叉树拓扑结构）。相比于 AVL 树，红黑树的插入和删除操作都只需要常数时间的旋转操作，这对于创建持久化数据结构是个重要优势。

#### 删除操作

删除节点的操作也是沿用了普通二叉树删除节点的操作，并在节点删除完成后再修复违反性质的情况。删除节点的过程如下：

1. 二叉搜索找到该节点，如果该节点左子节点或者右子节点为空，可以使用目标节点的子节点直接替代目标节点即可。
2. 如果目标节点有两个非空的子节点，可以找到目标节点的后继节点（successor），该后继节点左子节点必为空，用后继节点替换目标节点，并删除后继节点即可，问题转换为第一种情况。同样也可以使用前驱节点（predecessor）。

![RB Delete Cases](./rb-tree-delete-cases.jpg)

伪代码如下：

![RB-DELETE](./rb-tree-delete.png)

如果被删除的目标节点是红色节点，红黑树的 5 条性质不受影响，这种情况无需任何修复操作。如果被删除的目标节点是黑色，那么该节点到根节点的路径上黑高度-1，这时候如果目标节点的子节点是红色，那么可以简单的将子节点从红色变为黑色，即可修复黑高度平衡。但是如果子节点也是黑色，这时候没法简单修复，称为**双黑缺陷**。

算法导论中对于节点删除操作的修复情况划分不是太好，直接理解较为困难。这里先采用[邓俊辉](https://www.bilibili.com/video/av49361421?p=317)老师的方法。红黑树的节点删除然后修复违反性质重新平衡的过程同样应该从对应的 2-3-4 树去作理解，毕竟红黑树的黑平衡操作就是在模拟 2-3-4 的平衡，这样理解起来更加直观。

这里节点 x 是被删除节点的子节点，节点 x 是黑色，节点 p 是被删除节点的父节点，节点删除后 x 替代被删除节点的位置成为 p 的子节点。节点 s 是 p 的另外一个子节点，也是删除后 x 的兄弟节点。

**情况 1（BB-1）** x 是黑色，兄弟节点 s 是黑色，且 s 有一个红色子节点 t。

这种情况相当于 2-3-4 树中兄弟节点是 3 节点或者 4 节点，这时候可以从兄弟节点中借一个节点过来填补被删除节点的位置恢复 2-3-4 树的平衡。注意图中节点 x 是 p 的右子节点，对称的情况 x 是 p 的左子节点解决方法类似。

节点 t 和 s 组成了一个三节点，借一个节点给作为 x 的父节点即可修复 2-3-4 树平衡。但是在红黑树中注意到`t < s < p`，应该将节点 p 右旋，这样根节点 s 成为节点 p、t 的父节点，然后将节点 t 设置为黑色。图中的情况 t 是 s 的左子节点，如果 t 是 s 的右子节点，那么应该首先将红色右子节点转换为红色左子节点。

1~2 次旋转（s 旋转，p 旋转），3 次变色（t, s, p 各变色一次）。

图中白色节点代表颜色不定，黑色红色都可能。

![BB-1](./rb-tree-delete-bb1.png)

**情况 2（BB-2R）** x 是黑色，兄弟节点 s 是黑色且没有红色子节点，父节点 p 是红色。

这种情况在 2-3-4 树中相当于兄弟节点是 2 节点，没有多余节点可以借，但是父节点是 3 节点或者是 4 节点，可以将父节点 p 从上层脱离，与子节点 s 组合（merge）成一个 3 节点。因为 p 是红色，位于 3 节点或者 4 节点内，所以将 p 脱离不影响上层节点的平衡。需要注意的是节点 s 应该修改为红色，因为节点 s 和 p 合并组成一个 3 节点。

0 次旋转，2 次变色。

![BB-2R](./rb-tree-delete-bb2r.png)

**情况 2（BB-2B）** x 是黑色，兄弟节点 s 是黑色且没有红色子节点，父节点 p 是黑色。

与 BB-2R 一样需要将节点 p 从上层挪下来与 s 合并形成 3 节点，所以 s 变为红色。但是此时 p 节点下溢操作向上传递，需要循环处理直到根节点或者所在节点是红色节点（对应删除节点子节点是红色的简单修复情况）。

0 次旋转，1 次变色。

![BB-2B](./rb-tree-delete-bb2b.png)

**情况 3（BB-3）** x 是黑色，兄弟节点 s 是红色。

将节点 p 进行右旋，转换成 BB-1 和 BB-2R 的情况，不可能转换成 BB-2B 因为父节点 p 是红色。

1 次旋转，2 次变色。

![BB-2B](./rb-tree-delete-bb3.png)

最后情况转换流程与统计如下:

![BB Summary](./rb-tree-delete-summary.png)

删除操作修复需要的旋转操作是常数级别，染色操作最坏情况是$O(\log n)$。

从每个情况的条件很容易看出这四种情况涵盖了所有可能的情况。

下面将其对应到算法导论介绍的情况分类中。

![BB Summary](./rb-tree-delete-cases-flow.jpg)

算法导论中情况的划分对应的伪代码实现。需要注意的是 Case 1 可以转化为其他三种，Case 3 转化为 Case 4，Case 2 可能下一轮终结或者重新转换为所有情况。该伪代码实现的方式是将能够转为其他情况的 Case 1 放在最前面，使用一个`if`语句转化为其他三个 Case 的情况，然后使用 if-else 并列处理 Case 2 和 Case 3/Case 4。

Case 2 中如果 x.p 的颜色是红色则下一轮循环结束，从 11 行->1 行->23 行染色（对应 BB-2R 中的颜色操作）。23 行另外的情况就是递归到根节点，x 是根节点，将根节点颜色恢复为黑色。

21 行中 Case 3/Case 4 是已经完成修复，所以设置`x = T.root`终结循环。

![Delete Fixup](./rb-tree-delete-fixup.png)

#### 连接操作（Join）

#### 红黑树具有记忆性 13.4-7

#### 自上而下插入（Top-Down Insertion)

算法导论中描述的插入方法是自下而上插入，先从根节点自上而下找到树底部插入的目标位置，然后再自下而上的修复性质 4。

自上而下的插入方法可以从上到下只进行一遍节点遍历，但是遍历的过程中要保证当前节点始终是 2 节点或者 3 节点，这样就不会出现下 4 节点插入而违反性质 4 的情况。这种方法对应 2-3-4 树中的子上而下插入方法。

#### 自上而下删除（Top-Down Deletion)

[参考文章](https://eternallyconfuzzled.com/red-black-trees-c-the-most-common-balanced-binary-search-tree/)

#### 函数式实现

#### concurrent 红黑树

## AVL 树

CLRS 13-3

## Treap 树

CLRS 13-4

## 伸展树

Splay Tree

## B 树

## B+树
